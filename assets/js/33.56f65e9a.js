(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{445:function(t,a,r){"use strict";r.r(a);var v=r(2),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("DOM本身其实是有一些缺陷的，虚拟DOM的出现就是为此而诞生的，React、Vue都使用了虚拟DOM技术。")]),t._v(" "),a("h2",{attrs:{id:"dom缺陷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom缺陷"}},[t._v("#")]),t._v(" DOM缺陷")]),t._v(" "),a("p",[t._v("需要先了解"),a("strong",[t._v("DOM树生成")]),t._v("相关知识：")]),t._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/frontend/browser/render-process-js-dom-tree.html"}},[t._v("JavaScript影响DOM树构建")])],1)]),t._v(" "),a("p",[t._v("DOM提供了一组JavaScript接口用于操作树节点的，JavaScript操作DOM会"),a("strong",[t._v("影响到整个渲染流水线")]),t._v("。可能触发：")]),t._v(" "),a("ul",[a("li",[t._v("重排：样式计算、布局、绘制、栅格化、合成more...")]),t._v(" "),a("li",[t._v("重绘")]),t._v(" "),a("li",[t._v("合成")]),t._v(" "),a("li",[t._v("强制同步布局")]),t._v(" "),a("li",[t._v("布局抖动\n对于复杂的页面，修改DOM树，执行一次重排or重绘等等都是非常耗时的，导致性能问题。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("需要一种方案减少JavaScript对DOM的操作 => 虚拟DOM")])]),a("h2",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("h3",{attrs:{id:"要做的事情"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#要做的事情"}},[t._v("#")]),t._v(" 要做的事情")]),t._v(" "),a("ul",[a("li",[t._v("页面发生变化的内容作用到虚拟DOM上，而非直接作用到DOM上。")]),t._v(" "),a("li",[t._v("变化作用到虚拟DOM上，不直接应用到DOM渲染页面，只调整虚拟DOM内部状态（操作虚拟DOM代价相对较低）。")]),t._v(" "),a("li",[t._v("当虚拟DOM收集到足够的变化，再一次性将这些变化作用到真实DOM。")])]),t._v(" "),a("h3",{attrs:{id:"react虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react虚拟dom"}},[t._v("#")]),t._v(" React虚拟DOM")]),t._v(" "),a("ul",[a("li",[t._v("创建虚拟DOM => 数据、JSX创建虚拟DOM，虚拟DOM创建真实DOM，触发渲染流程输出页面。")]),t._v(" "),a("li",[t._v("更新虚拟DOM => 数据变化，根据新数据创建一个新的虚拟DOM，React进行新旧虚拟DOM对比，找出变化的点，将变化的点一次性更新到真实DOM，触发渲染引擎更新流程输出新页面。\n"),a("img",{attrs:{src:"https://s2.loli.net/2022/10/11/FXZWiavtzLeqh32.png",alt:"React虚拟DOM流程"}})])]),t._v(" "),a("h3",{attrs:{id:"react-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[t._v("#")]),t._v(" React Fiber")]),t._v(" "),a("p",[t._v("React在新旧虚拟DOM比较的过程中，是在一个递归函数中执行的（算法reconciliation）。一般情况这个过程执行比较快，但是当虚拟DOM本身也很复杂的时候，"),a("strong",[t._v("执行比较函数有可能占据主线程很久")]),t._v("，这样会导致其他任务等待，页面会卡顿。为了解决这个问题，React重写reconciliation算法（Stack reconciler），改新算法Fiber reconciler。"),a("br"),t._v("\nFiber可以和协程关联起来，算法Fiber reconciler是在"),a("strong",[t._v("执行过程中能够出让主线程")]),t._v("，避免函数占用过久的问题。\n"),a("RouterLink",{attrs:{to:"/frontend/javascript/async-await.html"}},[t._v("关于协程一些点")])],1),t._v(" "),a("h2",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),a("h3",{attrs:{id:"双缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双缓存"}},[t._v("#")]),t._v(" 双缓存")]),t._v(" "),a("p",[t._v("开发游戏或处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但很多图形都很复杂且需要大量运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么会造成一个后果，就是在显示一个稍微复杂点的图像的过程中，会看到的页面效果可能是一部分一部分地显示出来，在页面刷新的过程中，会让用户感到画面闪烁。"),a("br"),t._v("\n使用双缓存，先将计算的中间结果存放在另一个缓冲区，等全部的计算结束，该缓冲区已经存储了完整的图形，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样使得整个图像的输出非常稳定。"),a("br"),t._v(" "),a("strong",[t._v("可以把虚拟DOM看成是DOM的一个buffer")]),t._v("，和图形显示一样，会在完成一次完整的操作之后，再去把结果应用到DOM上，能减少一些不必要的更新，同时还能保证DOM的稳定输出。")]),t._v(" "),a("h3",{attrs:{id:"mvc模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc模式"}},[t._v("#")]),t._v(" MVC模式")]),t._v(" "),a("p",[t._v("MVC将数据和视图进行分离，面对复杂项目，大大降低项目耦合度，便于维护。"),a("br"),t._v("\n核心点：")]),t._v(" "),a("ul",[a("li",[t._v("数据和视图分离，不允许直接通信。")]),t._v(" "),a("li",[t._v("通信通过控制器来完成。")])]),t._v(" "),a("p",[t._v("一般的通信路径 => 视图发生变化，通知控制器，控制器判断是否更新数据模型。基于MVC演变出MVP（Model-View-Presenter）、MVVM。\n"),a("img",{attrs:{src:"https://s2.loli.net/2022/10/11/uL8WilEBY21tSVy.png",alt:"MVC设计模式"}})]),t._v(" "),a("h3",{attrs:{id:"react-redux-mvc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-redux-mvc"}},[t._v("#")]),t._v(" React + Redux => MVC")]),t._v(" "),a("p",[t._v("React（虚拟DOM）=> View视图\nRedux => Model数据模型 + Controller控制器"),a("br")]),t._v(" "),a("ul",[a("li",[t._v("控制器监听DOM变化，DOM发生变化事件，控制器通知模型更新数据；")]),t._v(" "),a("li",[t._v("模型数据更新完毕，控制器通知视图模型数据发生了变化；")]),t._v(" "),a("li",[t._v("视图接收到通知，根据模型数据生成新虚拟DOM；")]),t._v(" "),a("li",[t._v("新旧虚拟DOM进行比较，找出变化的节点；")]),t._v(" "),a("li",[t._v("变化的虚拟DOM => 作用到DOM触发更新；")]),t._v(" "),a("li",[t._v("DOM变化触发渲染流程；\n"),a("img",{attrs:{src:"https://s2.loli.net/2022/10/12/L4Ckv37DgzMxBT5.png",alt:"React Redux MVC"}})])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("ul",[a("li",[t._v("操作DOM会触发一系列渲染流程；")]),t._v(" "),a("li",[t._v("虚拟DOM减少了一些对DOM不必要的操作；")]),t._v(" "),a("li",[t._v("虚拟DOM是双缓存思想的一种体现，解决页面的无效刷新和闪屏；")])])])}),[],!1,null,null,null);a.default=_.exports}}]);