(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{440:function(t,v,_){"use strict";_.r(v);var s=_(2),r=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),v("p",[t._v("浏览器在提交文档数据后（导航流程），开始进行页面渲染。"),v("br"),t._v("\n我们在开发HTML、CSS、JavaScript后，浏览器打开就可以展示页面。")]),t._v(" "),v("ul",[v("li",[t._v("HTML(Hyper Text Markup Language)"),v("br"),t._v(" "),v("strong",[t._v("标签（标记） + 文本 => HTML文件内容")]),v("br"),t._v("\n每个标签都有自己的语义，浏览器根据标签的语义正确的展示文本内容。")]),t._v(" "),v("li",[t._v("CSS(Cascading Style Sheets)"),v("br"),t._v(" "),v("strong",[t._v("选择器 + 属性 => CSS")]),v("br"),t._v("\n改变HTML内容的字体大小、颜色等等，需要CSS来实现，通过选择器定位到HTML标签内容，渲染引擎根据属性正确显示HTML内容。")]),t._v(" "),v("li",[t._v("JavaScript"),v("br"),t._v(" "),v("strong",[t._v("让网页更加动态，能够操作HTML和CSS")])])]),t._v(" "),v("p",[v("strong",[t._v("渲染流水线")]),t._v(" => 渲染进程执行过程中会被拆分为很多个"),v("strong",[t._v("子阶段")]),t._v("，输入HTML文件经过很多个子阶段到最后渲染显示。"),v("br"),t._v("\n渲染流水线经历的子阶段：")]),t._v(" "),v("ul",[v("li",[t._v("DOM树构建 => HTML转成DOM树")]),t._v(" "),v("li",[t._v("CSS样式计算 => CSS转成styleSheets并且计算DOM节点样式")]),t._v(" "),v("li",[t._v("生成布局树 => DOM + styleSheets计算布局信息生成布局树")]),t._v(" "),v("li",[t._v("分图层 => 对布局树进行分层，生成分层树")]),t._v(" "),v("li",[t._v("图层绘制 => 对每个图层绘制生成绘制指令列表，提交给合成线程")]),t._v(" "),v("li",[t._v("栅格化 => 合成线程将图层分成图块，图块进行栅格化生成位图（栅格化线程池来维护栅格化任务使用GPU加速将图块转成位图并保存在GPU内存中）")]),t._v(" "),v("li",[t._v("合成显示 => 等待图块变成位图（光栅化）后，合成线程发送绘制图块DrawQuad指令通知浏览器进程，浏览器进程使用GPU进程内存中位图生成页面将其显示到显示器\n"),v("img",{attrs:{src:"https://s2.loli.net/2022/08/30/Pl2IM4jut67ocsf.png",alt:"渲染引擎流程"}})])]),t._v(" "),v("h2",{attrs:{id:"dom树构建"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dom树构建"}},[t._v("#")]),t._v(" DOM树构建")]),t._v(" "),v("p",[t._v("为何需要构建DOM树？"),v("br"),t._v(" "),v("strong",[t._v("浏览器无法直接理解使用HTML文件")]),t._v("，所以需要将HTML转换成浏览器能理解的"),v("strong",[t._v("DOM树结构")]),t._v("。"),v("br"),t._v("\n构建流程：输入HTML文件 => "),v("strong",[t._v("HTML解析器解析")]),t._v(" => 输出DOM树。"),v("br"),t._v("\ndocument对象就是DOM树的根节点，DOM和HTML内容基本一致，但DOM保存在"),v("strong",[t._v("内存中的树状结构")]),t._v("，支持JavaScript查询或修改，"),v("RouterLink",{attrs:{to:"/frontend/browser/render-process-dom-tree.html"}},[t._v("JavaScript如何影响DOM树构建？")]),v("br"),t._v(" "),v("img",{attrs:{src:"https://s2.loli.net/2022/08/29/2zFWdlMtaoIuU1S.png",alt:"DOM树结构"}})],1),t._v(" "),v("h2",{attrs:{id:"样式计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#样式计算"}},[t._v("#")]),t._v(" 样式计算")]),t._v(" "),v("p",[t._v("CSS样式来源：")]),t._v(" "),v("ul",[v("li",[t._v("link引入的外部CSS文件")]),t._v(" "),v("li",[t._v("style标签内的CSS")]),t._v(" "),v("li",[t._v("标签元素style属性内嵌的CSS")]),t._v(" "),v("li",[t._v("浏览器内置提供的默认userAgent样式表")])]),t._v(" "),v("h3",{attrs:{id:"_1-将css转换为stylesheets结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-将css转换为stylesheets结构"}},[t._v("#")]),t._v(" 1. 将CSS转换为styleSheets结构")]),t._v(" "),v("p",[t._v("浏览器无法直接理解纯文本CSS样式，当渲染引擎接受到CSS文件，执行转换操作，将CSS文本转换为浏览器能理解的"),v("strong",[t._v("styleSheets结构")]),t._v("，styleSheets结构同样的也具备查询修改的功能。")]),t._v(" "),v("h3",{attrs:{id:"_2-标准化stylesheets-样式表-中的属性值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-标准化stylesheets-样式表-中的属性值"}},[t._v("#")]),t._v(" 2. 标准化styleSheets（样式表）中的属性值")]),t._v(" "),v("p",[t._v("浏览器能理解样式表后，CSS里面有很多属性值并不是标准的计算值，要统一转成渲染引擎理解的标准值。"),v("br"),t._v(" "),v("strong",[t._v("常见的：1em、blue、bold => 标准化后 => 16px、rgb(0,0,255)、700;")])]),t._v(" "),v("div",{staticClass:"language-css line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-css"}},[v("code",[v("span",{pre:!0,attrs:{class:"token selector"}},[t._v("body")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 1em "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),v("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("blue"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),v("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bold"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("h3",{attrs:{id:"_3-计算dom树中每个节点的具体样式值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-计算dom树中每个节点的具体样式值"}},[t._v("#")]),t._v(" 3.计算DOM树中每个节点的具体样式值")]),t._v(" "),v("p",[v("strong",[t._v("计算方式 => 继承规则 + 层叠规则")]),v("br"),t._v("\nCSS继承规则："),v("strong",[t._v("所有DOM的子节点都会继承其父节点的样式。")]),v("br"),t._v("\nCSS样式层叠："),v("strong",[t._v("定义了如何合并来自多个源的属性值的算法。")])]),t._v(" "),v("h2",{attrs:{id:"布局树生成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#布局树生成"}},[t._v("#")]),t._v(" 布局树生成")]),t._v(" "),v("p",[t._v("此时有了DOM树以及标签元素各自的样式，但是还是无法显示页面，因为还不知道DOM标签元素的"),v("strong",[t._v("几何位置")]),t._v("信息。所以接下来需要计算DOM树中"),v("strong",[t._v("可见元素的几何位置")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"_1-创建布局树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建布局树"}},[t._v("#")]),t._v(" 1.创建布局树")]),t._v(" "),v("p",[t._v("DOM树中有可能包含很多不可见元素（display: none），所以在显示之前，需要额外创建一个"),v("strong",[t._v("只包含可见元素的布局树")]),t._v("。"),v("br"),t._v(" "),v("strong",[t._v("DOM树 + 样式表 => 生成只包含可见元素的布局树")]),t._v("。"),v("br"),t._v("\n浏览器要做的事情：")]),t._v(" "),v("ul",[v("li",[t._v("遍历DOM树可见节点，添加到布局中；")]),t._v(" "),v("li",[t._v("不可见节点被布局树忽略；")])]),t._v(" "),v("h3",{attrs:{id:"_2-布局计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-布局计算"}},[t._v("#")]),t._v(" 2.布局计算")]),t._v(" "),v("p",[t._v("有了完整的布局树之后，需要开始"),v("strong",[t._v("计算布局树各个节点的坐标位置")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"分图层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分图层"}},[t._v("#")]),t._v(" 分图层")]),t._v(" "),v("p",[t._v("有了布局树，每个元素的具体位置也算出来了，接下来需要进行分层，为何还需要分层呢？"),v("br"),t._v("\n因为页面上有很多复杂效果："),v("strong",[t._v("3D变换、页面滚动、z-index（z轴排序）")]),t._v("，这些效果的实现，需要"),v("strong",[t._v("渲染引擎为这些特定的节点生成专用的图层，并且最终生成一颗图层树（LayerTree）")]),t._v("，最后将图层进行叠加构成了最终的页面图。"),v("br"),t._v("\n一般情况下，布局树并非每个节点都包含一个图层，如果某个节点没有对应的图层，那么会继承父节点所在的图层，"),v("strong",[t._v("每个节点都会直接或间接属于一个图层。")]),v("br"),t._v("\n什么情况下，渲染引擎会为特定节点创建新的图层？")]),t._v(" "),v("ul",[v("li",[t._v("拥有层叠上下文属性的元素，会被提升为单独一个图层。\n"),v("ul",[v("li",[t._v("明确定位属性的元素（position: fixed）")]),t._v(" "),v("li",[t._v("定义透明属性属性的元素（opacity: 0.5）")]),t._v(" "),v("li",[t._v("css滤镜")]),t._v(" "),v("li",[t._v("z-index")])])]),t._v(" "),v("li",[t._v("页面裁剪（clip）的地方也会创建为图层\n"),v("ul",[v("li",[t._v("常见的div内容文本过多被裁剪显示")]),t._v(" "),v("li",[t._v("出现滚动条，会被单独提升为一层")])])])]),t._v(" "),v("h2",{attrs:{id:"图层绘制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[t._v("#")]),t._v(" 图层绘制")]),t._v(" "),v("p",[t._v("图层树构建完成后，渲染引擎会对图层树中每个图层进行绘制。"),v("br"),t._v("\n一个图层的绘制会被拆分成很多个绘制指令，这些小指令按照顺序组成一个待绘制表（用来记录绘制顺序和绘制指令的列表）。"),v("br"),t._v("\n绘制指令：绘制边框、背景、颜色more...")]),t._v(" "),v("h2",{attrs:{id:"栅格化raster-gpu生成位图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栅格化raster-gpu生成位图"}},[t._v("#")]),t._v(" 栅格化raster（GPU生成位图）")]),t._v(" "),v("p",[t._v("绘制表准备完毕后，主线程通知（commit）"),v("strong",[t._v("合成线程")]),t._v("开始对图层进行处理。"),v("br"),t._v("\n前置知识：")]),t._v(" "),v("ul",[v("li",[t._v("屏幕上页面的可见区域称为视口（ViewProt）。一般一个页面很大，但是用户只能看到其中一部分，这部分就是ViewProt。")]),t._v(" "),v("li",[t._v("有时候图层很大，页面需要滚动才能看完，但是对于用户的视口只能看到一小部分，为了避免不必要的开销，没必要绘制图层的所有内容。")]),t._v(" "),v("li",[t._v("栅格化、光栅化 => 图块生成位图。")])]),t._v(" "),v("p",[t._v("合成线程如何工作？")]),t._v(" "),v("ul",[v("li",[t._v("合成线程将图层进行划分为图块（tile），一般256 * 256 or 512 * 512。")]),t._v(" "),v("li",[t._v("然后合成线程按照ViewProt附近的图块优先去生成位图（栅格化 or 光栅化），图块是栅格化执行的最小单位。")]),t._v(" "),v("li",[t._v("渲染进程维护了一个栅格化的线程池，所有图块的栅格化任务都在线程池内执行。")]),t._v(" "),v("li",[t._v("渲染进程把栅格化任务发送给GPU（GPU加速），在GPU中执行生成图块的位图（GPU栅格化），保存在GPU内存中。")])]),t._v(" "),v("h2",{attrs:{id:"合成显示"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#合成显示"}},[t._v("#")]),t._v(" 合成显示")]),t._v(" "),v("p",[t._v("当所有的图块被栅格化，合成线程生成一个绘制图块的指令（DrawQuad），提交命令给浏览器进程。"),v("br"),t._v("\n浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后配合GPU内存中的位图，将页面内容进行绘制合成，最后将页面内容显示到屏幕上。")]),t._v(" "),v("h2",{attrs:{id:"渲染流程相关的概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程相关的概念"}},[t._v("#")]),t._v(" 渲染流程相关的概念")]),t._v(" "),v("h3",{attrs:{id:"重排-更改元素的几何属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重排-更改元素的几何属性"}},[t._v("#")]),t._v(" 重排 -- 更改元素的几何属性")]),t._v(" "),v("p",[t._v("通过JavaScript或者CSS修改了元素的几何位置（布局）、尺寸属性，比如元素宽高（div.style.height = xxx），浏览器会重新触发布局、分图层等之后的一系列子阶段，这个过程称之为重排。重排需要再"),v("strong",[t._v("走一遍完整的渲染流水线，开销最大")]),t._v("。")]),t._v(" "),v("ul",[v("li",[t._v("DOM元素删除、添加")]),t._v(" "),v("li",[t._v("改变位置")]),t._v(" "),v("li",[t._v("改变尺寸（宽高、内外边距...）")]),t._v(" "),v("li",[t._v("改变浏览器窗口尺寸（resize）")]),t._v(" "),v("li",[t._v("激活CSS伪类")]),t._v(" "),v("li",[t._v("设置style属性改变结点样式的")])]),t._v(" "),v("h3",{attrs:{id:"重绘-更改元素的绘制属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重绘-更改元素的绘制属性"}},[t._v("#")]),t._v(" 重绘 -- 更改元素的绘制属性")]),t._v(" "),v("p",[t._v("JavaScript更改元素的背景色（div.style.background = red），因为没有引起几何位置的变换，所以布局阶段不会执行，直接进入绘制阶段，然后执行之后的一系列子阶段，这个过程称之为重绘。"),v("strong",[t._v("重绘省去了布局和分图层阶段，执行效率比重排更高。")])]),t._v(" "),v("ul",[v("li",[t._v("color")]),t._v(" "),v("li",[t._v("border-style")]),t._v(" "),v("li",[t._v("visibility")]),t._v(" "),v("li",[t._v("background")]),t._v(" "),v("li",[t._v("text-decoration")]),t._v(" "),v("li",[t._v("box-shadow")])]),t._v(" "),v("h3",{attrs:{id:"直接合成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接合成"}},[t._v("#")]),t._v(" 直接合成")]),t._v(" "),v("p",[t._v("更改一个不需要布局也不需要绘制的属性，渲染引擎直接跳过布局和绘制，只执行后续合成操作，比如CSS的transform实现动画效果（transform:translate(0, 0)），可以避开重排和重绘，直接在"),v("strong",[t._v("合成线程")]),t._v("上（非主线程）上执行合成操作，效率最高。")]),t._v(" "),v("ul",[v("li",[t._v("在非主线程上合成，并没有占用主线程资源")]),t._v(" "),v("li",[t._v("同时避开了布局、分层、绘制两个阶段")])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("ul",[v("li",[t._v("触发重排reflow、重绘repaint的操作尽量放一起，比如改变DOM高度和设置margin分开写的，可能会触发两次重排。")]),t._v(" "),v("li",[t._v("框架的虚拟DOM层计算出操作DOM前后总的差异，一起提交给浏览器，减少触发重排重绘的次数。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);