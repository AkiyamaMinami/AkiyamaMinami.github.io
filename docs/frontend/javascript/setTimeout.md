---
title: Web API -- setTimeout
categories:
 - Browser
tags:
 - setTimeout
date: 2022-08-24
sidebar: 'auto'
---

## 前言
* 一个定时器，指定某函数多少毫秒后执行。
* return 一个整数代表定时器的编号。
* 通过编号可以取消定时器。
```js
function foo() {
    console.log('hi~')
}
// 1秒后调用foo函数
let timer = setTimeout(foo, 1000)
// clearTimeout(timer)
```

## 浏览器如何实现setTimeout
渲染进程中主线程去执行任务的机制：
1. 任务添加到消息队列
2. 主线程依赖**事件循环去按照顺序执行消息队列中的任务**
常见的一些事件（**事件其实就可以概括认为是任务**，循环监听事件发生，一旦发生，产生任务进入消息队列，等待执行）：
* 事件：接收到HTML文档数据 => 任务：渲染引擎将“解析DOM”事件（任务）添加到消息队列。；
* 事件：用户改变浏览器窗口大小 => 任务：渲染引擎将“重新布局”的事件添加到消息队列。
* 事件：触发JavaScript引擎垃圾回收机制 => 任务：渲染引擎将“垃圾回收”任务添加到消息队列中。
    注意：为什么JavaScript垃圾回收的任务被渲染引擎接手了？
* 事件：需要执行一段异步JavaScript代码 => 任务：将执行任务添加到消息队列中。
总结：执行一段异步任务，需要先把任务添加到消息队列。
### 定时器的特殊性
定时器需要指定时间间隔然后调用，而消息队列中的任务是按照顺序执行的，所以定时器的回调函数不能直接添加到消息队列中。
Chrome中除了正常使用的消息队列，额外还有一个消息队列，该队列中维护了**需要延迟执行的任务**。
## 总结