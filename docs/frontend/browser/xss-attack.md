---
title: XSS跨站脚本攻击
categories:
 - Browser
tags:
 - xss
 - HttpOnly
date: 2022-10-21
sidebar: 'auto'
---
## 前言
浏览器同源策略隔离了各个站点之间DOM、页面数据、网络的互相通信，虽然严格的同源策略提高了安全性，但同时束缚了Web了，比如默认XMLHttpRequest和Fetch 无法跨站请求资源。所以权衡了安全和自由之后，可以通过CORS策略来支持跨域，默认页面中可以引用任意第三方资源（同时引入CSP策略来加以限制）。<br/>
CORS和页面支持引入第三方资源带来的安全问题，常见的就是XSS攻击。

## XSS攻击
XSS => Cross Site Scripting，为了与“CSS”区分开来，故简称XSS。<br/>
:::tip
XSS攻击是指往HTML文件 or DOM中注入恶意脚本，当用户浏览页面时利用注入的恶意脚本对用户进行攻击的一种手段。
:::
一开始，这种攻击的实现是通过跨域实现的，所以叫“跨域脚本”。现如今向HTML文件注入恶意代码的方式更多了，跨域注入脚本已经不是唯一的手段了，但XSS名字一直保留至今。<br/>
浏览器是无法区分哪些脚本是恶意注入or正常页面的脚本，所以恶意注入的JavaScript拥有其他正常脚本的所有权限。一般情况下恶意脚本会做的事情：
* 窃取Cookie => document.cookie获取，然后通过XMLHttpRequest or Fetch借助CORS功能将数据发送给恶意服务器，拿到用户Cookie后模拟用户登录。
* 监听用户行为 => 恶意的JavaScript可以使用addEventListener接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。
* 修改DOM伪造假的登录窗口，欺骗用户输入用户名和密码。
* 在页面内生成浮窗广告，影响用户体验。

## 如何注入恶意脚本？
常见的三种注入方式：
* 存储型XSS攻击
* 反射型XSS攻击
* 基于DOM的XSS攻击
### 存储型XSS攻击
![存储型XSS.png](https://s2.loli.net/2022/10/21/I9AQ6gXCayR75eK.png)
主要步骤：
1. 利用站点漏洞（服务器对数据过滤不严格）将一段恶意JavaScript代码提交给网站的数据库中。
2. 用户向网站请求包含了恶意JavaScript脚本的页面。
3. 当用户浏览该页面，恶意脚本就会将用户的Cookie等数据上传到服务器。
### 反射型XSS攻击
用户提交给网站的内容中包含了恶意脚本 => 网站把接收到的恶意脚本返回（反射）给用户<br/>
常见的会通过QQ群或者邮件等渠道诱导用户去点击恶意链接，所以对于一些链接需要谨慎：
```http
http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>
```
反射型和存储型区别：Web服务器**不会存储反射型XSS攻击的恶意脚本**，这是和存储型XSS攻击不同的地方。
### 基于DOM的XSS攻击
该攻击是不涉及到页面的Web服务器的。主要是通过各种手段将恶意脚本注入到用户页面中，常见的**通过网络劫持**在页面传输过程中修改HTML页面的内容：
* WiFi路由器劫持。
* 本地恶意软件劫持。
* 共同点 => 都在Web资源传输过程or在用户使用页面的过程中修改Web页面的数据。

## 如何阻止XSS攻击
* 存储型XSS和反射型XSS => 是需要服务端处理出现的安全漏洞的。
* 基于DOM的XSS攻击是在浏览器端完成的 => 属于前端的安全漏洞。
* 共同点：向浏览器中注入恶意脚本，再通过恶意脚本将用户信息发送到恶意服务器上。
  
所以我们需要**阻止恶意JavaScript脚本的注入和恶意消息的发送**来避免XSS。

### 服务端对输入脚本进行过滤或转码
在服务器端将一些关键的字符进行转码：
```json
code: <script>alert('你被xss攻击了')</script>
// 进行过滤 => 把<script>标签的内容全部过滤
code
// 进行转码 => 浏览器是不会执行这段转码脚本的
code: &lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;
```

### 充分使用CSP
实施严格的CSP主要的几个功能：
* 限制加载其他域下的资源文件，即使插入了一个JS文件，这个外域的JS文件是无法被加载的。
* 禁止跨域向第三方域提交数据，这样用户数据就不会外泄。
* 禁止执行内联脚本和未授权的脚本。
* CSP提供了上报机制，帮助我们尽快发现有哪些XSS攻击。

### 使用HttpOnly属性
很多XSS攻击都是来盗用Cookie的，所以还可以通过HttpOnly属性来保护Cookie。一般服务器可以将某些Cookie设置为HttpOnly标志，HttpOnly是服务器通过HTTP响应头来设置的。使用HttpOnly标记的Cookie只能使用在HTTP请求过程，无法通过JavaScript（document.cookie）来读取这段Cookie。
```http
set-cookie: XXXXXX; HttpOnly
```

## 总结
XSS核心是向页面注入恶意脚本，然后将重要数据窃取上传至服务器。<br/>
常见三种方式：
* 存储型XSS攻击（服务器漏洞注入）
* 反射型XSS攻击（服务器漏洞注入）
* 基于DOM的XSS攻击（客户端注入）

常见解决策略：
* 服务端对输入内容过滤转码
* 利用CSP机制
* HttpOnly保护Cookie
* 添加验证码防止脚本冒充用户提交危险操作，对于一些不受信任的输入，可以限制其输入长度，增大XSS攻击的难度。