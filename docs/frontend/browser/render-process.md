---
title: 渲染阶段HTML、CSS、JavaScript是如何构建页面的？
categories:
 - Browser
# tags:
#  - DOM生成
#  - 样式计算
#  - 布局
date: 2022-08-28
sidebar: 'auto'
---

## 前言
浏览器在提交文档数据后（导航流程），开始进行页面渲染。<br/>
我们在开发HTML、CSS、JavaScript完成后，浏览器打开就可以展示页面。
* HTML(Hyper Text Markup Language)
  标签（标记） + 文本 => HTML文件内容。<br/>
  每个标签都有自己的语义，浏览器根据标签的语义正确的展示文本内容。
* CSS(Cascading Style Sheets)
  选择器 + 属性 => CSS<br/>
  改变HTML内容的字体大小、颜色more...，需要CSS来实现，通过选择器定位到HTML标签内容，渲染引擎根据属性正确显示HTML内容。
* JavaScript
  让网页更加动态，能够操作HTML和CSS

渲染进程执行的过程中会被拆分为很多个子阶段，输入HTML文件经过很多个子阶段到最后渲染，
这样的处理过程可以称为**渲染流水线**。
渲染流水线经历的子阶段：
* DOM树构建 => HTML转成DOM树
* CSS样式计算 => CSS转成styleSheets并且计算DOM节点样式
* 生成布局树 => DOM + styleSheets 生成布局树并且计算布局信息
* 分图层 => 对布局树进行分层，生成分层树
* 图层绘制 => 对每个图层生成绘制表，提交给合成线程
* GPU栅格化 => 合成线程将图层分成图块，在栅格化线程池中经由GPU将图块转成位图
* 合成显示 => 合成线程发送绘制图块DrawQuad指令给浏览器进程，浏览器进程根据DrawQuad配合GPU进程生成的位图生成页面将其显示到显示器
我们需要关注的点：
* 子阶段开始前输入的内容
* 子阶段处理的过程
* 子阶段结束后生成的内容
## DOM树构建
为何需要构建DOM树？<br/>
**浏览器无法直接理解使用HTML文件，**所以需要将HTML转换成浏览器能理解的**DOM树结构**。
**输入HTML文件 => HTML解析器解析 => 输出DOM树**
document就是DOM结构，内容和HTML文件内容基本一致，但是DOM保存在内存中的树结构中，支持JavaScript查询或修改。
![DOM树结构](https://s2.loli.net/2022/08/29/2zFWdlMtaoIuU1S.png)

## 样式计算
CSS样式来源：
* link引入的外部CSS文件
* <style>标签内的CSS
* 标签元素style属性内嵌的CSS
* 浏览器内置提供的默认userAgent样式表
### 1.CSS转换为styleSheets结构
浏览器无法直接理解纯文本CSS样式，当渲染引擎接受到CSS文件，执行转换操作，将CSS文本转换为浏览器能理解的**styleSheets结构**。styleSheets结构同样的也具备查询修改的功能。
### 2.标准化styleSheets（样式表）中的属性值
浏览器能理解样式表后，CSS里面有很多属性值并不是标准的计算值，要统一转成渲染引擎理解的标准值。
**常见的：1em、blue、bold => 标准化后 => 16px、rgb(0,0,255)、700;**
```css
body { font-size: 1em }
p {color:blue;}
div {font-weight: bold}
```
### 3.计算DOM树中每个节点的具体样式值
**计算方式 => 继承规则 + 层叠规则**
CSS继承规则：**所有DOM的子节点都会继承其父节点的样式。**
CSS样式层叠：**定义了如何合并来自多个源的属性值的算法。**


## 布局树生成
此时有了DOM树和DOM树元素各自的样式，但是还是无法显示页面，因为还不知道**DOM元素的几何位置信息。**所以接下来需要计算**DOM树中可见元素的几何位置**。
### 1.创建布局树
DOM树中有可能包含很多不可见元素（display: none），所以在显示之前，**需要额外创建一个只包含可见元素的布局树。**
**DOM树 + 样式表 => 生成只包含可见元素的布局树**
浏览器大致要做的事情：
* 遍历DOM树可见节点，添加到布局中；
* 不可见节点被布局树忽略；
### 2.布局计算
有了完整的布局树之后，需要开始**计算布局树各个节点的坐标位置**。

## 分层（图层）
有了布局树，每个元素的具体位置也算出来了，接下来需要进行分层。
为何还需要分层？
因为页面上游很多复杂效果：3D变换、页面滚动、z-index（z轴排序），这些效果的实现，需要**渲染引擎为这些特定的节点生成专用的图层，并且最终生成一颗图层树（LayerTree）**，最后将图层进行叠加构成了最终的页面图。
一般情况下，布局树并非每个节点都包含一个图层，如果某个节点没有对应的图层，那么会继承父节点所在的图层，**每个节点都会直接或间接属于一个图层。**
什么情况下，渲染引擎会为特定节点创建新的图层？
* 拥有层叠上下文属性的元素，会被提升为单独一个图层。
  明确定位属性的元素（position: fixed）;
  定义透明属性属性的元素（opacity: 0.5）;
  css滤镜;
  z-index;
* 页面裁剪（clip）的地方也会创建为图层
  常见的div内容文本过多被裁剪显示，或者出现滚动条，是会被单独提升为一层。

## 图层绘制
图层树构建完成后，渲染引擎会对图层树中每个图层进行绘制。
一个图层的绘制会被拆分成很多个绘制指令，按照这些小指令按照顺序组成一个待绘制表。
绘制指令：绘制边框、背景、颜色more...

## 栅格化raster（GPU生成位图）
绘制表是用来记录绘制顺序和绘制指令的列表，实际去绘制操作的是渲染进程中的**合成线程去完成的**。当图层的绘制表准备就绪，**主线程将绘制表提交commit给合成线程**。
合成线程如何工作？
视口：屏幕上页面的可见区域称为视口（ViewProt）。
一般一个页面很大，但是用户只能看到其中一部分，这部分就是ViewProt。
有时候，有的图层很大，页面需要滚动才能看完，但是对于用户的视口只能看到一小部分，所以为了避免开销，没必要绘制图层的所有内容。
基于这种情况，合成线程将图层进行划分为图块（tile）,一般256 * 256 or 512 * 512；
然后合成线程按照ViewProt附近的图块优先生成位图，图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有图块的栅格化都在线程池内执行。栅格化的过程会使用GPU进行加速生成，使用GPU生成位图的过程叫GPU栅格化，生成的位图被保存在GPU内存中。渲染进程把生成图块的指令发送给GPU，在GPU中执行生成图块的位图，保存在内存中。

## 合成显示
当所有的图块被栅格化，合成线程生成一个绘制图块的指令（DrawQuad），提交命令给浏览器进程，浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存中页面内容显示在屏幕上。

## 渲染流程相关的概念
### 重排 -- 更改元素的几何属性
通过JavaScript或者CSS修改了元素的几何位置属性，比如元素宽高，**浏览器会触发重新布局、解析之后的一系列子阶段，这个过程称之为重排。重排需要更新完整的渲染流水线，开销最大。**
### 重绘 -- 更改元素的绘制属性
JavaScript更改元素的背景色，布局阶段不会执行，因为没有引起几何位置的变换，直接进入绘制阶段，然后执行之后的一系列子阶段，这个过程称之为重绘。**重绘省去了布局和分层阶段，执行效率比重排更高。**
### 直接合成
更改一个不需要布局也不需要绘制的属性，渲染引擎直接跳过布局和绘制，只执行后续合成操作。
CSS的transform实现动画效果，可以避开重排和重绘，直接在非主线程上执行合成动画操作，效率最高，因为在非主线程上合成，并没有占用主线程资源，同时也避开了布局和绘制两个子阶段。

## 总结
* 触发重排reflow、重绘repaint的操作尽量放一起，比如改变DOM高度和设置margin分开写的，可能会触发两次重排。
* 通过虚拟DOM层计算出操作后总的差异，一起提交给浏览器，减少触发重排重绘的次数。